<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FastAlign: Ultimate Editor</title>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --panel-bg: #ffffff;
            --border-color: #d1d5db;
            --primary: #2563eb;
            --header-height: 90px;
            --ruler-height: 30px;
            --names-width: 220px;
        }

        * { box-sizing: border-box; }

        body, html {
            margin: 0; padding: 0;
            height: 100%; width: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            overflow: hidden;
            user-select: none;
        }

        #app {
            display: flex; flex-direction: column;
            height: 100vh; width: 100vw;
        }

        #controls {
            height: var(--header-height);
            background: var(--panel-bg);
            border-bottom: 1px solid var(--border-color);
            display: flex; align-items: center;
            padding: 0 20px; gap: 15px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            flex-shrink: 0; z-index: 20;
        }

        .control-group { display: flex; flex-direction: column; gap: 4px; }
        label { font-size: 11px; font-weight: 700; text-transform: uppercase; color: #6b7280; }
        button, select, input {
            padding: 6px 10px; border: 1px solid #d1d5db; border-radius: 4px;
            background: white; font-size: 13px; cursor: pointer;
        }
        button:hover { background-color: #f3f4f6; }
        button.active { background-color: var(--primary); color: white; border-color: var(--primary); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

        #viewer-grid {
            flex: 1; display: grid;
            grid-template-columns: var(--names-width) minmax(0, 1fr);
            grid-template-rows: var(--ruler-height) minmax(0, 1fr);
            grid-template-areas: "corner ruler" "names seq";
            overflow: hidden; position: relative;
            background: #fff;
        }

        #area-corner { grid-area: corner; background: #f3f4f6; border-right: 1px solid var(--border-color); border-bottom: 1px solid var(--border-color); z-index: 10; }
        
        #area-ruler {
            grid-area: ruler; background: #f3f4f6;
            border-bottom: 1px solid var(--border-color);
            position: relative; overflow: hidden; cursor: s-resize;
        }
        #area-ruler:hover { background: #e5e7eb; }

        #area-names {
            grid-area: names; background: #fff;
            border-right: 1px solid var(--border-color);
            position: relative; overflow: hidden; z-index: 5;
            box-shadow: 2px 0 5px rgba(0,0,0,0.05); cursor: e-resize;
        }
        #area-names:hover { background: #f9fafb; }

        #area-seq {
            grid-area: seq; overflow: auto; position: relative;
            background: #fff; outline: none;
            cursor: text;
        }
        #area-seq.grabbing { cursor: grabbing; }

        canvas { display: block; }
        #cvs-seq { position: sticky; top: 0; left: 0; }
        #scroll-sizer { position: absolute; top: 0; left: 0; width: 1px; height: 1px; z-index: -1; }

        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.95);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 9999; opacity: 0; pointer-events: none; transition: opacity 0.2s;
        }
        #overlay.active { opacity: 1; pointer-events: all; }
        .spinner {
            width: 30px; height: 30px;
            border: 3px solid #e5e7eb; border-top: 3px solid var(--primary);
            border-radius: 50%; animation: spin 0.8s linear infinite;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }

        .hint-text {
            font-size: 11px; color: #4b5563; margin-left: auto; text-align: right;
            line-height: 1.3; background: #f3f4f6; padding: 5px 10px; border-radius: 4px; border: 1px solid #e5e7eb;
        }
        .tag { display: inline-block; padding: 1px 4px; background: #e5e7eb; border-radius: 3px; font-weight: 600; font-size: 10px; }
    </style>
</head>
<body>

<div id="app">
    <div id="controls">
        <div class="control-group">
            <label>Load Data</label>
            <input type="file" id="inp-file" accept=".fasta,.fa,.txt">
        </div>
        <div class="control-group">
            <label>Demo</label>
            <button id="btn-example">Load Example</button>
        </div>
        <div style="width:1px; height:30px; background:#e5e7eb; margin:0 10px;"></div>
        <div class="control-group">
            <label>History</label>
            <button id="btn-undo" title="Ctrl+Z">‚ü≤ Undo</button>
        </div>
        <div style="width:1px; height:30px; background:#e5e7eb; margin:0 10px;"></div>
        <div class="control-group">
            <label>View Mode</label>
            <div style="display:flex;">
                <button id="btn-nt" class="active" style="border-top-right-radius:0; border-bottom-right-radius:0;">Nucleotide</button>
                <button id="btn-aa" style="border-top-left-radius:0; border-bottom-left-radius:0; border-left:none;">Amino Acid</button>
            </div>
        </div>
        <div class="control-group" id="grp-frame" style="opacity:0.4; pointer-events:none;">
            <label>Reading Frame</label>
            <select id="sel-frame">
                <option value="1">Frame 1</option>
                <option value="2">Frame 2</option>
                <option value="3">Frame 3</option>
            </select>
        </div>
        <div class="hint-text">
            <strong>Full Edit Support</strong><br>
            <span class="tag">Drag Panels</span> Select Row/Col <br>
            <span class="tag">Cmd+Z</span> Undo
        </div>
    </div>

    <div id="viewer-grid">
        <div id="area-corner"></div>
        <div id="area-ruler"><canvas id="cvs-ruler"></canvas></div>
        <div id="area-names"><canvas id="cvs-names"></canvas></div>
        <div id="area-seq" tabindex="0"><div id="scroll-sizer"></div><canvas id="cvs-seq"></canvas></div>
    </div>
</div>

<div id="overlay">
    <div class="spinner"></div>
    <div id="overlay-msg" style="margin-top:10px; font-weight:500;">Processing...</div>
</div>

<script>
// --- Config ---
const CONFIG = {
    font: "14px 'Courier New', monospace",
    labelFont: "12px system-ui, sans-serif",
    charWidth: 12,
    rowHeight: 24,
    rulerTickStep: 10,
    maxHistory: 30, // Limit memory usage
    colors: {
        NT: { 'A': '#c8e6c9', 'G': '#fff9c4', 'C': '#b3e5fc', 'T': '#ffcdd2', 'U': '#ffcdd2', '-': '#ffffff', 'default': '#f5f5f5' },
        AA: { 'A': '#80a0f0', 'R': '#f01505', 'N': '#00ff00', 'D': '#c048c0', 'C': '#f08080', 'Q': '#00ff00', 'E': '#c048c0', 'G': '#f09048', 'H': '#15a4a4', 'I': '#80a0f0', 'L': '#80a0f0', 'K': '#f01505', 'M': '#80a0f0', 'F': '#80a0f0', 'P': '#ffff00', 'S': '#00ff00', 'T': '#00ff00', 'W': '#80a0f0', 'Y': '#15a4a4', 'V': '#80a0f0', '*': '#999999', '-': '#ffffff', 'default': '#ffffff' }
    }
};

const CODON_TABLE = {
    'ATA':'I', 'ATC':'I', 'ATT':'I', 'ATG':'M', 'ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T',
    'AAC':'N', 'AAT':'N', 'AAA':'K', 'AAG':'K', 'AGC':'S', 'AGT':'S', 'AGA':'R', 'AGG':'R',
    'CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L', 'CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',
    'CAC':'H', 'CAT':'H', 'CAA':'Q', 'CAG':'Q', 'CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R',
    'GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V', 'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A',
    'GAC':'D', 'GAT':'D', 'GAA':'E', 'GAG':'E', 'GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',
    'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S', 'TTC':'F', 'TTT':'F', 'TTA':'L', 'TTG':'L',
    'TAC':'Y', 'TAT':'Y', 'TAA':'*', 'TAG':'*', 'TGC':'C', 'TGT':'C', 'TGA':'*', 'TGG':'W',
};

// --- State ---
const state = {
    rawSequences: [],
    viewSequences: [],
    history: [], // Undo stack
    dragSaved: false, // Flag to ensure we only save once per drag operation
    mode: 'NT',
    frame: 1,
    maxLength: 0,
    selection: null, 
    mouse: { isDown: false, target: null, startR: 0, startC: 0, lastHoverC: 0 }
};

// --- DOM ---
const dom = {
    file: document.getElementById('inp-file'),
    btnEx: document.getElementById('btn-example'),
    btnUndo: document.getElementById('btn-undo'),
    btnNt: document.getElementById('btn-nt'),
    btnAa: document.getElementById('btn-aa'),
    selFrame: document.getElementById('sel-frame'),
    grpFrame: document.getElementById('grp-frame'),
    overlay: document.getElementById('overlay'),
    areaSeq: document.getElementById('area-seq'),
    areaNames: document.getElementById('area-names'),
    areaRuler: document.getElementById('area-ruler'),
    cvsSeq: document.getElementById('cvs-seq'),
    cvsNames: document.getElementById('cvs-names'),
    cvsRuler: document.getElementById('cvs-ruler'),
    sizer: document.getElementById('scroll-sizer')
};

const ctxSeq = dom.cvsSeq.getContext('2d', { alpha: false });
const ctxNames = dom.cvsNames.getContext('2d');
const ctxRuler = dom.cvsRuler.getContext('2d');

// --- Init ---
function init() {
    dom.file.addEventListener('change', e => loadFile(e.target.files[0]));
    dom.btnEx.addEventListener('click', loadExample);
    dom.btnUndo.addEventListener('click', undo);
    dom.btnNt.addEventListener('click', () => setMode('NT'));
    dom.btnAa.addEventListener('click', () => setMode('AA'));
    dom.selFrame.addEventListener('change', () => { state.frame = +dom.selFrame.value; recalc(); });

    dom.areaSeq.addEventListener('scroll', () => requestAnimationFrame(render));
    window.addEventListener('resize', onResize);
    
    // Mouse
    dom.areaSeq.addEventListener('mousedown', (e) => onMouseDown(e, 'SEQ'));
    dom.areaNames.addEventListener('mousedown', (e) => { e.preventDefault(); onMouseDown(e, 'NAMES'); });
    dom.areaRuler.addEventListener('mousedown', (e) => { e.preventDefault(); onMouseDown(e, 'RULER'); });
    
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    
    // Keyboard
    dom.areaSeq.addEventListener('keydown', onKeyDown);
    // Global key listener for Ctrl+Z even if focus is slightly off, though ideally areaSeq should have focus
    window.addEventListener('keydown', (e) => {
        if((e.ctrlKey || e.metaKey) && e.key === 'z') {
            e.preventDefault();
            undo();
        }
    });

    onResize();
}

// --- History / Undo ---

function saveState() {
    // Deep copy sequences. JSON parse/stringify is fast enough for typical alignment sizes (up to few MBs)
    // For larger datasets, a more sophisticated differential tracking would be needed.
    const snapshot = {
        seqs: JSON.parse(JSON.stringify(state.rawSequences)),
        sel: state.selection ? { ...state.selection } : null
    };

    state.history.push(snapshot);
    if(state.history.length > CONFIG.maxHistory) {
        state.history.shift();
    }
}

function undo() {
    if(state.history.length === 0) return;
    
    const prev = state.history.pop();
    state.rawSequences = prev.seqs;
    state.selection = prev.sel;
    
    recalc();
}

// --- Data ---
function loadFile(file) {
    if(!file) return;
    showOverlay(true);
    const reader = new FileReader();
    reader.onload = e => parseFasta(e.target.result);
    reader.readAsText(file);
}

function loadExample() {
    showOverlay(true);
    setTimeout(() => {
        let sb = [];
        const bases = ['A','C','G','T'];
        for(let i=1; i<=20; i++) {
            sb.push(`>Seq_${i}`);
            let s = "";
            for(let j=0; j<150; j++) {
                if(Math.random()<0.05) s+="-"; 
                else s += bases[Math.floor(Math.random()*4)];
            }
            sb.push(s);
        }
        parseFasta(sb.join('\n'));
    }, 50);
}

function parseFasta(text) {
    const lines = text.split(/\r?\n/);
    const seqs = [];
    let name = null, buf = [];
    for(let line of lines) {
        line = line.trim();
        if(!line) continue;
        if(line.startsWith('>')) {
            if(name) seqs.push({name, seq: buf.join('').split('')});
            name = line.substring(1).trim();
            buf = [];
        } else {
            buf.push(line.toUpperCase().replace(/[^A-Z-]/g, ''));
        }
    }
    if(name) seqs.push({name, seq: buf.join('').split('')});
    state.rawSequences = seqs;
    state.selection = null;
    state.history = []; // Clear history on new load
    recalc();
    showOverlay(false);
}

function setMode(m) {
    state.mode = m;
    if(m === 'NT') {
        dom.btnNt.classList.add('active'); dom.btnAa.classList.remove('active');
        dom.grpFrame.style.opacity = '0.4'; dom.grpFrame.style.pointerEvents = 'none';
    } else {
        dom.btnAa.classList.add('active'); dom.btnNt.classList.remove('active');
        dom.grpFrame.style.opacity = '1'; dom.grpFrame.style.pointerEvents = 'auto';
    }
    state.selection = null;
    recalc();
}

function recalc() {
    // Update Button State
    dom.btnUndo.disabled = (state.history.length === 0);
    dom.btnUndo.style.opacity = (state.history.length === 0) ? "0.5" : "1";

    if(!state.rawSequences.length) return;
    if(state.mode === 'NT') {
        state.viewSequences = state.rawSequences.map(s => ({ name: s.name, seq: s.seq }));
    } else {
        const offset = state.frame - 1;
        state.viewSequences = state.rawSequences.map(s => {
            const dna = s.seq;
            const aa = [];
            for(let i=offset; i<dna.length; i+=3) {
                if(i+2 >= dna.length) break;
                const codon = dna.slice(i, i+3).join('');
                if(codon.includes('-')) aa.push('-');
                else aa.push(CODON_TABLE[codon] || 'X');
            }
            return { name: s.name, seq: aa };
        });
    }

    let max = 0;
    state.viewSequences.forEach(s => max = Math.max(max, s.seq.length));
    state.maxLength = max;
    
    dom.sizer.style.width = (max * CONFIG.charWidth + 200) + 'px';
    dom.sizer.style.height = (state.viewSequences.length * CONFIG.rowHeight) + 'px';
    render();
}

// --- Inputs ---

function getCoords(e, type) {
    let r = 0, c = 0;
    const rect = (type==='SEQ'?dom.areaSeq:(type==='NAMES'?dom.areaNames:dom.areaRuler)).getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    if(type === 'SEQ') {
        c = Math.floor((x + dom.areaSeq.scrollLeft) / CONFIG.charWidth);
        r = Math.floor((y + dom.areaSeq.scrollTop) / CONFIG.rowHeight);
    } else if (type === 'NAMES') {
        r = Math.floor((y + dom.areaSeq.scrollTop) / CONFIG.rowHeight);
    } else if (type === 'RULER') {
        c = Math.floor((x + dom.areaSeq.scrollLeft) / CONFIG.charWidth);
    }
    return { r, c };
}

function onMouseDown(e, type) {
    dom.areaSeq.focus();
    
    const { r, c } = getCoords(e, type);
    const maxR = Math.max(0, state.viewSequences.length - 1);

    state.mouse.isDown = true;
    state.mouse.startR = Math.min(r, maxR);
    state.mouse.startC = Math.max(0, c);
    state.mouse.lastHoverC = Math.max(0, c);

    if(type === 'SEQ' && isInsideSelection(r, c) && !e.shiftKey) {
        state.mouse.target = 'MOVE';
        dom.areaSeq.classList.add('grabbing');
    } else {
        state.mouse.target = type;
        if(type === 'SEQ') {
            state.selection = { r1: r, c1: c, r2: r, c2: c };
        } else if (type === 'NAMES') {
            state.selection = { r1: r, r2: r, c1: 0, c2: 99999999 }; 
        } else if (type === 'RULER') {
            state.selection = { r1: 0, r2: maxR, c1: c, c2: c };
        }
    }
    render();
}

function onMouseMove(e) {
    if(!state.mouse.isDown) return;
    
    const { r, c } = getCoords(e, 'SEQ');
    const safeR = Math.max(0, Math.min(state.viewSequences.length-1, r));
    const safeC = Math.max(0, c);

    if(state.mouse.target === 'SEQ') {
        state.selection.r1 = Math.min(state.mouse.startR, safeR);
        state.selection.r2 = Math.max(state.mouse.startR, safeR);
        state.selection.c1 = Math.min(state.mouse.startC, safeC);
        state.selection.c2 = Math.max(state.mouse.startC, safeC);
        render();
    } else if(state.mouse.target === 'NAMES') {
        state.selection.r1 = Math.min(state.mouse.startR, safeR);
        state.selection.r2 = Math.max(state.mouse.startR, safeR);
        state.selection.c1 = 0; state.selection.c2 = 99999999;
        render();
    } else if(state.mouse.target === 'RULER') {
        state.selection.c1 = Math.min(state.mouse.startC, safeC);
        state.selection.c2 = Math.max(state.mouse.startC, safeC);
        state.selection.r1 = 0; state.selection.r2 = state.viewSequences.length - 1;
        render();
    } else if(state.mouse.target === 'MOVE') {
        const delta = safeC - state.mouse.lastHoverC;
        if(delta !== 0) {
            // Save state right before the first drag move occurs
            if(!state.dragSaved) {
                saveState();
                state.dragSaved = true;
            }
            attemptMoveSelection(delta);
            state.mouse.lastHoverC = safeC;
        }
    }
}

function onMouseUp() {
    state.mouse.isDown = false;
    state.mouse.target = null;
    state.dragSaved = false; // Reset drag save flag
    dom.areaSeq.classList.remove('grabbing');
}

function isInsideSelection(r, c) {
    const s = state.selection;
    if(!s) return false;
    return r >= s.r1 && r <= s.r2 && c >= s.c1 && c <= s.c2;
}

// --- Logic ---

function onKeyDown(e) {
    if(!state.selection) return;
    
    // Ignore if Ctrl is pressed (let global handler take Ctrl+Z)
    if(e.ctrlKey || e.metaKey) return;

    if(e.key === ' ') {
        e.preventDefault();
        saveState();
        insertGap();
    } else if (e.key === 'Backspace' || e.key === 'Delete') {
        e.preventDefault();
        saveState();
        handleDeletion();
    } else if (state.mode === 'NT') {
        const char = e.key.toUpperCase();
        if(/^[ACGTUN-]$/.test(char)) {
            e.preventDefault();
            saveState();
            overwriteBlock(char);
        }
    }
}

function handleDeletion() {
    const { r1, r2, c1, c2 } = state.selection;
    const allRows = state.viewSequences.length;

    if(c1 === 0 && c2 >= 99999) { // Full Row
        state.rawSequences.splice(r1, r2 - r1 + 1);
        state.selection = null;
        recalc();
        return;
    }
    if(r1 === 0 && r2 >= allRows - 1) { // Full Col
        const count = c2 - c1 + 1;
        state.rawSequences.forEach(s => {
            const dna = s.seq;
            if(state.mode === 'NT') {
                if(c1 < dna.length) dna.splice(c1, count);
            } else {
                const off = state.frame - 1;
                const idx = (c1 * 3) + off;
                if(idx < dna.length) dna.splice(idx, count * 3);
            }
        });
        state.selection = null;
        recalc();
        return;
    }

    deleteBlock();
}

function deleteBlock() {
    const { r1, r2, c1, c2 } = state.selection;
    const count = c2 - c1 + 1;
    const safeC2 = (c2 > 99999) ? state.maxLength + 10 : c2;
    const safeCount = safeC2 - c1 + 1;

    for(let r=r1; r<=r2; r++) {
        if(!state.rawSequences[r]) continue;
        const dna = state.rawSequences[r].seq;
        if(state.mode === 'NT') {
            dna.splice(c1, safeCount);
        } else {
            const off = state.frame - 1;
            const idx = (c1 * 3) + off;
            if(idx < dna.length) dna.splice(idx, safeCount * 3);
        }
    }
    state.selection = { r1, r2, c1, c2: c1 };
    recalc();
}

function insertGap() {
    const { r1, r2, c1 } = state.selection;
    for(let r=r1; r<=r2; r++) {
        if(!state.rawSequences[r]) continue;
        const dna = state.rawSequences[r].seq;
        if(state.mode === 'NT') {
            dna.splice(c1, 0, '-');
        } else {
            const idx = (c1 * 3) + (state.frame - 1);
            dna.splice(idx, 0, '-', '-', '-');
        }
    }
    recalc();
}

function overwriteBlock(char) {
    const { r1, r2, c1, c2 } = state.selection;
    for(let r=r1; r<=r2; r++) {
        if(!state.rawSequences[r]) continue;
        const dna = state.rawSequences[r].seq;
        const effectiveC2 = Math.min(c2, dna.length + 50); 
        
        for(let c=c1; c<=effectiveC2; c++) {
            if(c < dna.length) dna[c] = char;
            else dna.push(char);
        }
    }
    recalc();
}

function attemptMoveSelection(dir) {
    if(dir === 0) return;
    const { r1, r2, c1, c2 } = state.selection;
    
    // 1. Validation
    let canMove = true;
    for(let r=r1; r<=r2; r++) {
        if(!state.rawSequences[r]) continue;
        const dna = state.rawSequences[r].seq;
        
        let start, end, step;
        if(state.mode === 'NT') { start = c1; end = c2; step = 1; }
        else { const off = state.frame - 1; start = c1*3+off; end = c2*3+off+2; step = 3; }

        const checkEnd = Math.min(end, dna.length - 1);

        if(dir > 0) {
            for(let k=1; k<=step; k++) {
                if(checkEnd + k < dna.length && dna[checkEnd + k] !== '-') { canMove = false; break; }
            }
        } else {
            if(start - step < 0) { canMove = false; break; }
            for(let k=1; k<=step; k++) {
                if(dna[start - k] !== '-') { canMove = false; break; }
            }
        }
        if(!canMove) break;
    }

    if(!canMove) return;

    // 2. Execution
    for(let r=r1; r<=r2; r++) {
        if(!state.rawSequences[r]) continue;
        const dna = state.rawSequences[r].seq;
        
        let start, end, step;
        if(state.mode === 'NT') { start = c1; end = c2; step = 1; }
        else { const off = state.frame - 1; start = c1*3+off; end = c2*3+off+2; step = 3; }

        const effectiveEnd = Math.min(end, dna.length - 1);

        if(dir > 0) {
            while(dna.length <= effectiveEnd + step) dna.push('-');
            for(let i = effectiveEnd; i >= start; i--) {
                dna[i+step] = dna[i];
                dna[i] = '-';
            }
        } else {
            for(let i = start; i <= effectiveEnd; i++) {
                dna[i-step] = dna[i];
                dna[i] = '-';
            }
        }
    }
    
    state.selection.c1 += (dir>0?1:-1);
    state.selection.c2 += (dir>0?1:-1);
    recalc();
}

// --- Render ---

function showOverlay(b) { dom.overlay.classList.toggle('active', b); }

function onResize() {
    dom.cvsNames.width = dom.areaNames.clientWidth;
    dom.cvsNames.height = dom.areaNames.clientHeight;
    dom.cvsRuler.width = dom.areaRuler.clientWidth;
    dom.cvsRuler.height = dom.areaRuler.clientHeight;
    dom.cvsSeq.width = dom.areaSeq.clientWidth;
    dom.cvsSeq.height = dom.areaSeq.clientHeight;
    render();
}

function render() {
    if(!state.viewSequences.length && state.rawSequences.length === 0) {
        ctxSeq.clearRect(0,0,dom.cvsSeq.width, dom.cvsSeq.height);
        return;
    }

    const vW = dom.cvsSeq.width, vH = dom.cvsSeq.height;
    const scrollLeft = dom.areaSeq.scrollLeft, scrollTop = dom.areaSeq.scrollTop;

    const startRow = Math.floor(scrollTop / CONFIG.rowHeight);
    const endRow = Math.min(state.viewSequences.length, Math.ceil((scrollTop + vH) / CONFIG.rowHeight));
    const startCol = Math.floor(scrollLeft / CONFIG.charWidth);
    const endCol = Math.ceil((scrollLeft + vW) / CONFIG.charWidth);

    // Sequence
    ctxSeq.fillStyle = '#ffffff'; ctxSeq.fillRect(0,0,vW,vH);
    ctxSeq.font = CONFIG.font; ctxSeq.textBaseline = 'middle'; ctxSeq.textAlign = 'center';
    const colors = state.mode === 'NT' ? CONFIG.colors.NT : CONFIG.colors.AA;

    for(let r=startRow; r<endRow; r++) {
        const seq = state.viewSequences[r].seq;
        const y = (r * CONFIG.rowHeight) - scrollTop;
        for(let c=startCol; c<endCol; c++) {
            if(c >= seq.length) break;
            const char = seq[c];
            const x = (c * CONFIG.charWidth) - scrollLeft;
            ctxSeq.fillStyle = colors[char] || colors['default'];
            ctxSeq.fillRect(x, y, CONFIG.charWidth, CONFIG.rowHeight);
            if(char !== '-') {
                ctxSeq.fillStyle = '#000';
                ctxSeq.fillText(char, x + CONFIG.charWidth/2, y + CONFIG.rowHeight/2);
            }
        }
    }

    // Selection
    if(state.selection) {
        const { r1, r2, c1, c2 } = state.selection;
        const visC2 = Math.min(c2, state.maxLength + 20); // visual clamp
        const sx = (c1 * CONFIG.charWidth) - scrollLeft;
        const sy = (r1 * CONFIG.rowHeight) - scrollTop;
        const w = Math.max(4, (visC2 - c1 + 1) * CONFIG.charWidth);
        const h = (r2 - r1 + 1) * CONFIG.rowHeight;
        
        ctxSeq.fillStyle = 'rgba(37, 99, 235, 0.2)'; ctxSeq.fillRect(sx, sy, w, h);
        ctxSeq.strokeStyle = 'rgba(37, 99, 235, 0.8)'; ctxSeq.lineWidth = 1; ctxSeq.strokeRect(sx, sy, w, h);
    }

    // Names
    ctxNames.fillStyle = '#fff'; ctxNames.fillRect(0,0,dom.cvsNames.width, dom.cvsNames.height);
    ctxNames.font = CONFIG.labelFont; ctxNames.textBaseline = 'middle'; ctxNames.textAlign = 'left';
    for(let r=startRow; r<endRow; r++) {
        const y = (r * CONFIG.rowHeight) - scrollTop;
        let isSel = state.selection && (r >= state.selection.r1 && r <= state.selection.r2);
        ctxNames.fillStyle = isSel ? '#eff6ff' : (r%2===0 ? '#f9fafb' : '#fff');
        ctxNames.fillRect(0, y, dom.cvsNames.width, CONFIG.rowHeight);
        ctxNames.fillStyle = isSel ? '#1e40af' : '#374151';
        ctxNames.fillText(state.viewSequences[r].name, 10, y + CONFIG.rowHeight/2);
    }

    // Ruler
    ctxRuler.fillStyle = '#f3f4f6'; ctxRuler.fillRect(0,0,dom.cvsRuler.width, dom.cvsRuler.height);
    ctxRuler.font = "10px sans-serif"; ctxRuler.textAlign = "center"; ctxRuler.strokeStyle = "#9ca3af";
    ctxRuler.beginPath();
    for(let c=startCol; c<endCol; c++) {
        const x = (c * CONFIG.charWidth) - scrollLeft + (CONFIG.charWidth/2);
        let isSel = state.selection && (c >= state.selection.c1 && c <= state.selection.c2);
        if(isSel) {
            ctxRuler.fillStyle = "rgba(37, 99, 235, 0.2)";
            ctxRuler.fillRect((c*CONFIG.charWidth)-scrollLeft, 0, CONFIG.charWidth, 30);
            ctxRuler.fillStyle = "#000";
        } else { ctxRuler.fillStyle = "#6b7280"; }

        const idx = c + 1;
        if(idx===1 || idx % CONFIG.rulerTickStep === 0) {
            ctxRuler.moveTo(x, 15); ctxRuler.lineTo(x, 30); ctxRuler.fillText(idx, x, 12);
        } else if(idx % (CONFIG.rulerTickStep/2)===0) {
            ctxRuler.moveTo(x, 22); ctxRuler.lineTo(x, 30);
        }
    }
    ctxRuler.stroke();
}

init();
</script>
</body>
</html>
