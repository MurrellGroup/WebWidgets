<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sequence Diversity & Visualization Tool</title>
    
    <!-- Load D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- Load MathJax for Equations -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        :root {
            --primary: #2c3e50;
            --accent: #3498db;
            --light-grey: #f8f9fa;
            --border: #ddd;
            --overlay-bg: rgba(255, 255, 255, 0.9);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 0;
            color: #333;
            background-color: #fff;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Tabs */
        .tab-nav {
            background: #eee;
            padding: 10px 20px 0 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 5px;
        }
        .tab-btn {
            padding: 10px 20px;
            border: 1px solid transparent;
            border-bottom: none;
            background: #ddd;
            cursor: pointer;
            border-radius: 5px 5px 0 0;
            font-weight: 600;
        }
        .tab-btn.active {
            background: #fff;
            border-color: var(--border);
            color: var(--primary);
        }

        .tab-content {
            display: none;
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }
        .tab-content.active { display: block; }

        /* General UI */
        h1, h2, h3 { color: var(--primary); margin-top: 0; }
        .container { max-width: 1400px; margin: 0 auto; width: 100%; }

        /* Controls */
        .controls {
            background: var(--light-grey);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border);
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: flex-end;
        }
        .control-group { display: flex; flex-direction: column; gap: 5px; }
        label { font-weight: 600; font-size: 0.85em; }
        input[type="text"], input[type="number"], select {
            padding: 6px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button {
            padding: 8px 16px;
            background-color: var(--accent);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.2s;
        }
        button:hover { background-color: #2980b9; }
        button.secondary { background-color: #7f8c8d; }
        
        /* Loading Overlay */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: var(--overlay-bg);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        .spinner {
            border: 8px solid #f3f3f3;
            border-top: 8px solid var(--accent);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Tables */
        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 0.9em; }
        th, td { text-align: left; padding: 10px; border-bottom: 1px solid #eee; }
        th { background-color: var(--primary); color: white; }
        tr:nth-child(even) { background-color: #f9f9f9; }

        /* Viz */
        #viz-header {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;
        }
        #viz-container {
            width: 100%;
            border: 1px solid #ccc;
            background: white;
            overflow: auto; /* Default scroll */
            position: relative;
        }
        
        .hidden { display: none !important; }

        /* Documentation Styles */
        .doc-block {
            background: #fff;
            border: 1px solid #eee;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            max-width: 900px;
        }
        code { background: #f4f4f4; padding: 2px 5px; border-radius: 3px; }
    </style>
</head>
<body>

<!-- LOADER -->
<div id="loader" class="hidden">
    <div class="spinner"></div>
    <div id="loader-text">Processing...</div>
</div>

<!-- TABS -->
<div class="tab-nav">
    <button class="tab-btn active" onclick="switchTab('tool')">Analysis Tool</button>
    <button class="tab-btn" onclick="switchTab('docs')">Documentation</button>
</div>

<!-- TAB 1: TOOL -->
<div id="tool" class="tab-content active">
    <div class="container">
        
        <div class="controls">
            <div class="control-group">
                <label>1. FASTA File</label>
                <input type="file" id="fastaFile" accept=".fasta,.fa,.txt">
            </div>

            <div class="control-group">
                <label>2. Group ID Method</label>
                <select id="groupMethod">
                    <option value="separator">Separator Character</option>
                    <option value="fixed">Fixed Length</option>
                </select>
            </div>

            <div class="control-group" id="setting-separator">
                <label>Separator Settings</label>
                <div style="display:flex; gap:5px;">
                    <input type="text" id="sepChar" placeholder="e.g. | or _" value="_" style="width: 50px;">
                    <select id="sepPos">
                        <option value="before">Before First</option>
                        <option value="after">After Last</option>
                    </select>
                </div>
            </div>

            <div class="control-group hidden" id="setting-fixed">
                <label>Fixed Length Settings</label>
                <div style="display:flex; gap:5px;">
                    <input type="number" id="fixedLen" value="4" min="1" style="width: 60px;">
                    <select id="fixedPos">
                        <option value="prefix">Prefix (Start)</option>
                        <option value="suffix">Suffix (End)</option>
                    </select>
                </div>
            </div>

            <div class="control-group">
                <label>3. Gap Handling</label>
                <select id="gapHandling">
                    <option value="pairwise_del">Ignore Gaps (Pairwise Deletion)</option>
                    <option value="mismatch">Treat Gaps as Mismatch</option>
                </select>
            </div>

            <div class="control-group">
                <label>4. Viz Reference</label>
                <select id="vizRefMethod">
                    <option value="group_consensus">Group Consensus</option>
                    <option value="first_in_group">First in Group</option>
                    <option value="alignment_consensus">Overall Consensus</option>
                    <option value="first_group_consensus">Consensus of First Group</option>
                    <option value="first_seq_include">First Seq in Alignment (Include)</option>
                    <option value="first_seq_exclude">First Seq in Alignment (Exclude)</option>
                    <option value="external_fasta">External FASTA</option>
                </select>
            </div>

            <div class="control-group hidden" id="setting-external-ref">
                <label>External Reference File</label>
                <input type="file" id="refFastaFile" accept=".fasta,.fa,.txt">
            </div>

            <div class="control-group">
                <label>&nbsp;</label>
                <button id="runBtn">Analyze & Visualize</button>
            </div>
        </div>

        <div id="results-area" class="hidden">
            <!-- Metrics -->
            <div class="section-header" style="display:flex; justify-content:space-between; margin-bottom:10px;">
                <h3>Within-Group Diversity Metrics</h3>
                <button class="secondary" id="downloadCsvBtn">Download CSV</button>
            </div>
            <div id="metrics-table-container"></div>

            <hr style="margin: 30px 0; border: 0; border-top: 1px solid #ddd;">

            <!-- Visualization -->
            <div id="viz-header">
                <h3>Alignment Visualization (Diff to Consensus)</h3>
                <div style="display:flex; gap: 10px; align-items: center;">
                    <div class="control-group" style="flex-direction: row; align-items: center; gap: 5px;">
                        <label>Horz:</label>
                        <input type="number" id="horzScale" value="100" step="10" style="width: 50px;">%
                    </div>
                    <div class="control-group" style="flex-direction: row; align-items: center; gap: 5px;">
                        <label>Vert:</label>
                        <input type="number" id="vertScale" value="100" step="10" style="width: 50px;">%
                    </div>
                    <div class="control-group" style="flex-direction: row; align-items: center; gap: 5px;">
                        <label>Label:</label>
                        <input type="number" id="labelScale" value="100" step="10" style="width: 50px;">%
                    </div>
                    <button class="secondary" id="updateScaleBtn">Update</button>
                    <button class="secondary" id="downloadSvgBtn">Download SVG</button>
                </div>
            </div>
            <p style="font-size: 0.9em; color: #666; margin-top:0;">
                Alternating grey bands indicate groups. <span style="color:red">â– </span> Colored blocks are mismatches from group consensus. 
                Vertical labels (left) show Group IDs.
            </p>
            <div id="viz-container"></div>
        </div>

    </div>
</div>

<!-- TAB 2: DOCUMENTATION -->
<div id="docs" class="tab-content">
    <div class="container">
        <h1>Methodology & Documentation</h1>
        
        <div class="doc-block">
            <h2>Average Pairwise Distance</h2>
            <p>
                The average pairwise distance quantifies the genetic diversity within a group by averaging the Hamming distance between all unique pairs of sequences in that group.
            </p>
            <p>
                Let \( S \) be a set of \( N \) sequences in a group. The Average Pairwise Distance \( D_{avg} \) is calculated as:
            </p>
            $$ D_{avg} = \frac{2}{N(N-1)} \sum_{i=1}^{N-1} \sum_{j=i+1}^{N} d(s_i, s_j) $$
            <p>
                Where \( d(s_i, s_j) \) is the distance between sequence \( i \) and sequence \( j \).
            </p>

            <h3>Gap Handling</h3>
            <p><strong>1. Treat Gaps as Mismatch:</strong></p>
            <p>
                Any position containing a gap (<code>-</code>) is treated as a valid character. If one sequence has a gap and the other has a nucleotide, it counts as a difference.
                $$ d(s_i, s_j) = \frac{\text{Count}(s_{i,k} \neq s_{j,k})}{L} $$
                Where \( L \) is the total length of the alignment.
            </p>

            <p><strong>2. Ignore Gaps (Pairwise Deletion):</strong></p>
            <p>
                For every pair of sequences, we only consider positions where <em>neither</em> sequence has a gap.
                $$ d(s_i, s_j) = \frac{\sum_{k} I(s_{i,k} \neq \text{gap} \land s_{j,k} \neq \text{gap} \land s_{i,k} \neq s_{j,k})}{\sum_{k} I(s_{i,k} \neq \text{gap} \land s_{j,k} \neq \text{gap})} $$
                If no valid positions exist for a pair, the distance is undefined (treated as 0 in implementation for stability, though mathematically null).
            </p>
        </div>

        <div class="doc-block">
            <h2>Average Entropy</h2>
            <p>
                Shannon entropy measures the variability at a specific site (column) in the alignment. We calculate the entropy for each column and then take the average across all columns.
            </p>
            <p>
                For a specific column \( k \), the entropy \( H_k \) is:
            </p>
            $$ H_k = - \sum_{x \in \{A,C,G,T,-\}} P(x) \log_2 P(x) $$
            <p>
                Where \( P(x) \) is the frequency of character \( x \) in column \( k \).
            </p>
            <p>
                The <strong>Average Entropy</strong> for the group is:
            </p>
            $$ H_{avg} = \frac{1}{L} \sum_{k=1}^{L} H_k $$
            
            <h3>Gap Handling</h3>
            <ul>
                <li><strong>Treat Gaps as Mismatch:</strong> The gap character <code>-</code> is included in the set of symbols. It contributes to the probability distribution \( P(x) \).</li>
                <li><strong>Ignore Gaps:</strong> Gaps are excluded from the frequency counts. \( P(x) \) is calculated based only on non-gap characters in that column. Columns consisting entirely of gaps have 0 entropy.</li>
            </ul>
        </div>
    </div>
</div>

<script>
    // --- STATE ---
    let rawSequences = [];
    let groupedData = {};
    let metricsData = [];
    let externalRefSeq = null;
    
    // Visualization Data Cache (so we can resize without recalculating everything)
    let vizCache = {
        flatData: [],
        boundaries: [],
        seqLength: 0
    };

    // --- DOM ELEMENTS ---
    const methodSelect = document.getElementById('groupMethod');
    const sepSettings = document.getElementById('setting-separator');
    const fixedSettings = document.getElementById('setting-fixed');
    const refMethodSelect = document.getElementById('vizRefMethod');
    const externalRefSettings = document.getElementById('setting-external-ref');
    const loader = document.getElementById('loader');

    // --- TABS ---
    function switchTab(tabId) {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        
        // Find button by onclick attribute match (simple hack) or relative index
        // Simpler: just loop and check text or handle manually.
        // Let's just find the button that targets this tab
        const btns = document.querySelectorAll('.tab-btn');
        if(tabId === 'tool') btns[0].classList.add('active');
        if(tabId === 'docs') btns[1].classList.add('active');

        document.getElementById(tabId).classList.add('active');
    }

    // Toggle Settings UI
    methodSelect.addEventListener('change', () => {
        if(methodSelect.value === 'separator') {
            sepSettings.classList.remove('hidden');
            fixedSettings.classList.add('hidden');
        } else {
            sepSettings.classList.add('hidden');
            fixedSettings.classList.remove('hidden');
        }
    });

    refMethodSelect.addEventListener('change', () => {
        if(refMethodSelect.value === 'external_fasta') {
            externalRefSettings.classList.remove('hidden');
        } else {
            externalRefSettings.classList.add('hidden');
        }
    });

    // --- MAIN LOGIC ---

    async function yieldToMain() {
        return new Promise(resolve => setTimeout(resolve, 0));
    }

    document.getElementById('runBtn').addEventListener('click', () => {
        const fileInput = document.getElementById('fastaFile');
        if(!fileInput.files.length) {
            alert("Please upload a FASTA file first.");
            return;
        }

        // Show Loader
        loader.classList.remove('hidden');
        
        // Allow UI to update (render loader) before heavy lifting
        setTimeout(async () => {
            try {
                const file = fileInput.files[0];
                const text = await file.text();
                
                // 1. Parse FASTA
                rawSequences = parseFasta(text);
                if(rawSequences.length === 0) {
                    alert("No sequences found. Check file format.");
                    loader.classList.add('hidden');
                    return;
                }

                // Load External Reference or handle First Seq Exclude
                const refMethod = document.getElementById('vizRefMethod').value;
                externalRefSeq = null; // reset

                if (refMethod === 'external_fasta') {
                    const refFileInput = document.getElementById('refFastaFile');
                    if (!refFileInput.files.length) {
                        alert("Please upload an external reference FASTA file.");
                        loader.classList.add('hidden');
                        return;
                    }
                    const refText = await refFileInput.files[0].text();
                    const refSeqs = parseFasta(refText);
                    if (refSeqs.length === 0) {
                        alert("No sequences found in external reference file.");
                        loader.classList.add('hidden');
                        return;
                    }
                    externalRefSeq = refSeqs[0].seq;
                } else if (refMethod === 'first_seq_exclude') {
                    // Save first sequence as reference and remove from analysis
                    externalRefSeq = rawSequences[0].seq;
                    rawSequences.shift();
                    if (rawSequences.length === 0) {
                        alert("No sequences left for analysis after excluding the first sequence.");
                        loader.classList.add('hidden');
                        return;
                    }
                }

                // 2. Group Sequences
                groupSequences();

                // 3. Compute Metrics
                await computeMetrics();

                // 4. Render Table
                renderTable();

                // 5. Prepare Viz Data
                await prepareVizData();
                
                // 6. Initial Render (Using scaling fields)
                renderVizWithScales();

                // Show sections
                document.getElementById('results-area').classList.remove('hidden');
            } catch (e) {
                console.error(e);
                alert("An error occurred during analysis: " + e.message);
            } finally {
                loader.classList.add('hidden');
            }
        }, 50);
    });

    function parseFasta(text) {
        const lines = text.split(/\r?\n/);
        const seqs = [];
        let currentHeader = null;
        let currentSeq = [];

        lines.forEach(line => {
            line = line.trim();
            if(!line) return;
            if(line.startsWith('>')) {
                if(currentHeader) {
                    seqs.push({ name: currentHeader, seq: currentSeq.join('').toUpperCase() });
                }
                currentHeader = line.substring(1); 
                currentSeq = [];
            } else {
                currentSeq.push(line);
            }
        });
        if(currentHeader) {
            seqs.push({ name: currentHeader, seq: currentSeq.join('').toUpperCase() });
        }
        return seqs;
    }

    function getGroupId(name) {
        const method = document.getElementById('groupMethod').value;
        
        if (method === 'separator') {
            const char = document.getElementById('sepChar').value || "_";
            const pos = document.getElementById('sepPos').value;
            // Escape special regex chars if necessary, but for now simple split
            const parts = name.split(char);
            
            if (parts.length < 2) return name; 
            return pos === 'before' ? parts[0] : parts[parts.length - 1];
        } else {
            const len = parseInt(document.getElementById('fixedLen').value) || 4;
            const pos = document.getElementById('fixedPos').value;
            
            if (name.length < len) return name;
            return pos === 'prefix' ? name.substring(0, len) : name.substring(name.length - len);
        }
    }

    function groupSequences() {
        groupedData = {};
        rawSequences.forEach(item => {
            const gid = getGroupId(item.name);
            if (!groupedData[gid]) groupedData[gid] = [];
            groupedData[gid].push(item);
        });
    }

    // --- METRICS ---

    async function computeMetrics() {
        metricsData = [];
        const gapMode = document.getElementById('gapHandling').value;
        let lastYield = Date.now();

        for (const [gid, seqs] of Object.entries(groupedData)) {
            if (seqs.length < 2) {
                metricsData.push({ group: gid, count: seqs.length, avgDist: 0, avgEntropy: 0 });
                continue;
            }

            const len = seqs[0].seq.length;

            // 1. Avg Pairwise Dist
            let totalDist = 0;
            let pairCount = 0;

            for (let i = 0; i < seqs.length; i++) {
                // Yield periodically to keep UI responsive
                if (Date.now() - lastYield > 50) {
                    await yieldToMain();
                    lastYield = Date.now();
                }
                for (let j = i + 1; j < seqs.length; j++) {
                    const s1 = seqs[i].seq;
                    const s2 = seqs[j].seq;
                    let mismatches = 0;
                    let validPositions = 0;

                    for (let k = 0; k < len; k++) {
                        const c1 = s1[k];
                        const c2 = s2[k];
                        const isGap1 = c1 === '-' || c1 === '.';
                        const isGap2 = c2 === '-' || c2 === '.';

                        if (gapMode === 'pairwise_del') {
                            if (!isGap1 && !isGap2) {
                                validPositions++;
                                if (c1 !== c2) mismatches++;
                            }
                        } else {
                            validPositions++;
                            if (c1 !== c2) mismatches++;
                        }
                    }

                    if (validPositions > 0) {
                        totalDist += (mismatches / validPositions);
                        pairCount++;
                    }
                }
            }
            const avgDist = pairCount > 0 ? (totalDist / pairCount) : 0;

            // 2. Avg Entropy
            let totalEntropy = 0;
            let entropyCols = 0;

            for (let k = 0; k < len; k++) {
                const counts = {};
                let colTotal = 0;

                for (let i = 0; i < seqs.length; i++) {
                    const char = seqs[i].seq[k];
                    const isGap = char === '-' || char === '.';
                    
                    if (gapMode === 'pairwise_del' && isGap) continue;
                    
                    counts[char] = (counts[char] || 0) + 1;
                    colTotal++;
                }

                if (colTotal > 0) {
                    let h = 0;
                    for (const char in counts) {
                        const p = counts[char] / colTotal;
                        h -= p * Math.log2(p);
                    }
                    totalEntropy += h;
                    entropyCols++;
                }
            }
            const avgEntropy = entropyCols > 0 ? (totalEntropy / entropyCols) : 0;

            metricsData.push({
                group: gid,
                count: seqs.length,
                avgDist: avgDist,
                avgEntropy: avgEntropy
            });
        }
    }

    function renderTable() {
        const container = document.getElementById('metrics-table-container');
        let html = `<table>
            <thead>
                <tr>
                    <th>Group ID</th>
                    <th>Seq Count</th>
                    <th>Avg Pairwise Distance</th>
                    <th>Avg Entropy (bits)</th>
                </tr>
            </thead>
            <tbody>`;
        
        metricsData.forEach(row => {
            html += `<tr>
                <td>${row.group}</td>
                <td>${row.count}</td>
                <td>${row.avgDist.toFixed(4)}</td>
                <td>${row.avgEntropy.toFixed(4)}</td>
            </tr>`;
        });
        html += `</tbody></table>`;
        container.innerHTML = html;
    }

    // --- VISUALIZATION PREP ---

    async function getConsensus(seqs) {
        if (seqs.length === 0) return "";
        const len = seqs[0].seq.length;
        let consensus = "";
        let lastYield = Date.now();

        for (let k = 0; k < len; k++) {
            // Yield if it's taking too long
            if (Date.now() - lastYield > 50) {
                await yieldToMain();
                lastYield = Date.now();
            }

            const counts = {};
            let maxChar = '-';
            let maxCount = -1;
            for (let i = 0; i < seqs.length; i++) {
                const char = seqs[i].seq[k];
                counts[char] = (counts[char] || 0) + 1;
                if (counts[char] > maxCount) {
                    maxCount = counts[char];
                    maxChar = char;
                }
            }
            consensus += maxChar;
        }
        return consensus;
    }

    async function prepareVizData() {
        const sortedGroups = Object.keys(groupedData).sort();
        const seqLength = rawSequences[0].seq.length;
        const refMethod = document.getElementById('vizRefMethod').value;
        
        let globalRef = null;
        if (refMethod === 'alignment_consensus') {
            globalRef = await getConsensus(rawSequences);
        } else if (refMethod === 'first_group_consensus') {
            if (sortedGroups.length > 0) {
                globalRef = await getConsensus(groupedData[sortedGroups[0]]);
            }
        } else if (refMethod === 'first_seq_include') {
            globalRef = rawSequences[0].seq;
        } else if (refMethod === 'first_seq_exclude' || refMethod === 'external_fasta') {
            globalRef = externalRefSeq;
            if (globalRef && globalRef.length !== seqLength) {
                console.warn("Reference length mismatch. Expected " + seqLength + " but got " + globalRef.length);
            }
        }

        let flatData = [];
        let groupBoundaries = [];
        let currentRow = 0;
        let lastYield = Date.now();

        for (const gid of sortedGroups) {
            const seqs = groupedData[gid];
            
            let groupRef = null;
            if (refMethod === 'group_consensus') {
                groupRef = await getConsensus(seqs);
            } else if (refMethod === 'first_in_group') {
                groupRef = seqs[0].seq;
            } else {
                groupRef = globalRef;
            }

            const startRow = currentRow;

            for (const s of seqs) {
                // Yield periodically
                if (Date.now() - lastYield > 50) {
                    await yieldToMain();
                    lastYield = Date.now();
                }

                const mismatches = [];
                for(let k=0; k<seqLength; k++) {
                    if (s.seq[k] !== groupRef[k]) {
                        mismatches.push({ pos: k, base: s.seq[k] });
                    }
                }
                flatData.push({
                    name: s.name,
                    group: gid,
                    row: currentRow,
                    mismatches: mismatches
                });
                currentRow++;
            }

            groupBoundaries.push({
                id: gid,
                start: startRow,
                end: currentRow
            });
        }

        vizCache = {
            flatData: flatData,
            boundaries: groupBoundaries,
            seqLength: seqLength,
            totalRows: currentRow
        };
    }

    // --- D3 RENDERING ---

    const colorScale = d3.scaleOrdinal()
            .domain(["A", "T", "G", "C", "-", "N"])
            .range(["#4daf4a", "#e41a1c", "#ff7f00", "#377eb8", "#999999", "#999999"])
            .unknown("#999999");

    function renderVizWithScales() {
        const hScale = (parseFloat(document.getElementById('horzScale').value) || 100) / 100;
        const vScale = (parseFloat(document.getElementById('vertScale').value) || 100) / 100;
        const lScale = (parseFloat(document.getElementById('labelScale').value) || 100) / 100;
        
        const baseCharW = 12;
        const baseRowH = 16;
        
        drawViz(baseCharW * hScale, baseRowH * vScale, lScale);
    }

    document.getElementById('updateScaleBtn').addEventListener('click', renderVizWithScales);

    function drawViz(charWidth, rowHeight, labelScale = 1.0) {
        const container = document.getElementById('viz-container');
        container.innerHTML = "";

        const margin = { top: 30, right: 10, bottom: 10, left: 40 }; 
        
        const totalW = (vizCache.seqLength * charWidth) + margin.left + margin.right;
        const totalH = (vizCache.totalRows * rowHeight) + margin.top + margin.bottom;
        
        const svg = d3.select("#viz-container")
            .append("svg")
            .attr("width", totalW)
            .attr("height", totalH)
            .style("display", "block")
            .style("font-family", "sans-serif");

        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // 1. Group Backgrounds & Vertical Labels
        vizCache.boundaries.forEach((grp, i) => {
            const grpY = grp.start * rowHeight;
            const grpH = (grp.end - grp.start) * rowHeight;
            const grpW = vizCache.seqLength * charWidth;

            // Band
            g.append("rect")
                .attr("x", 0) 
                .attr("y", grpY)
                .attr("width", grpW)
                .attr("height", grpH)
                .attr("fill", i % 2 === 0 ? "#ffffff" : "#f2f2f2");

            // Vertical Label
            g.append("text")
                .attr("transform", `translate(-15, ${grpY + grpH/2}) rotate(-90)`)
                .attr("text-anchor", "middle")
                .attr("dy", "0.35em") // v-center
                .style("font-weight", "bold")
                .style("font-size", (12 * labelScale) + "px") 
                .text(grp.id);
        });

        // 2. Mismatches
        const rectData = vizCache.flatData.flatMap(d => d.mismatches.map(m => ({ ...m, r: d.row })));
        
        const rects = g.selectAll(".mismatch")
            .data(rectData)
            .enter()
            .append("rect")
            .attr("x", d => d.pos * charWidth)
            .attr("y", d => d.r * rowHeight)
            .attr("width", charWidth)
            .attr("height", rowHeight)
            .attr("fill", d => colorScale(d.base));
        
        // Tooltips (only if not super dense)
        if (rowHeight > 5 && charWidth > 4) {
            rects.append("title").text(d => `${d.base} @ Pos ${d.pos+1}`);
        }

        // 3. Axis
        const xScale = d3.scaleLinear()
            .domain([1, vizCache.seqLength])
            .range([0, vizCache.seqLength * charWidth]);

        const axis = d3.axisTop(xScale);
        
        // Reduce ticks if very dense
        if(charWidth < 2) {
            axis.ticks(10);
        }

        g.append("g")
            .call(axis)
            .style("font-size", "10px");
    }

    // --- DOWNLOAD ---
    
    document.getElementById('downloadCsvBtn').addEventListener('click', () => {
        if(metricsData.length === 0) return;
        let csv = "Group ID,Sequence Count,Avg Pairwise Distance,Avg Entropy\n";
        metricsData.forEach(row => {
            csv += `${row.group},${row.count},${row.avgDist},${row.avgEntropy}\n`;
        });
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'sequence_metrics.csv';
        a.click();
    });

    document.getElementById('downloadSvgBtn').addEventListener('click', () => {
        const svgElement = document.querySelector('#viz-container svg');
        if(!svgElement) return;
        const serializer = new XMLSerializer();
        let source = serializer.serializeToString(svgElement);
        if(!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)){
            source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
        }
        source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
        const blob = new Blob([source], {type: "image/svg+xml;charset=utf-8"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'alignment_viz.svg';
        a.click();
    });

</script>

</body>
</html>